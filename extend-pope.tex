%!TEX root = dbproposal.tex

\subsection{Extensions to Property-Preserving Encryption}
The direct use of property-preserving encryption has a mixed history
with leakage attacks showing that deterministic and order-preserving
encryption reveal the entire stored dataset for many applications (see
work of the co-PI for an overview of leakage
attacks~\cite{SP:FVYSHG17}).

Despite these attacks, the ease and speed of configuring and using PPE
without replacing the entire software stack has encouraged its momentum
in the commercial sector. A natural question is, \emph{can we maintain
the benefits of PPE while avoiding these attacks?}

In this section, we investigate solutions that keep intact
the design principal of PPE: the only place that the database should
have to change is the comparison operator (equality, comparison, or
distance).  The database should still be able use standard indexing
mechanisms.  We note it is possible to override this operator to be
interactive and require help from a client without altering the overall
indexing structure.

\paragraph{Prior work.}
We are aware of two main works that follow the approach of PPE with added interactivity.  Two of the co-PIs recently introduced a new cryptographic approach, called POPE, to
support range queries over encrypted data, providing stronger security than
previous order-preserving encryptions~\cite{CCS:RACY16}.  In contrast to
existing OPE schemes, the server builds a novel indexing structure called a
POPE tree, in which each node has a {\it unsorted buffer} and a sorted list of
elements.  Thanks to this, the scheme can perform {\it lazy indexing, by
sorting values only when necessary}. In particular, on each range query, the
scheme sorts the part of the tree that forms the boundary of the search,
leaving much of the data untouched.

The other work is Arx due to Poddar, Boelter, and Popa~\cite{EPRINT:PodBoePop16}.  The
Arx protocol builds an index for answering
range queries without revealing all order relationships to the
server. The index stores all encrypted values in a binary
tree so range queries can be answered by traversing this
tree for the end points. Using Yao's garbled circuits, the
server traverses the index without learning the values it is
comparing or the result of the comparison at each stage.  Each garbled circuit can only be used once for a single comparison.  The client and server work together to create new garbled circuits (and OT pairs).

\paragraph{POPE for similarity of high-dimensional data.}
Our main approach is developing PPE that operates using just-in-time
advice from the client.  In POPE, this took the form of asking the client to
sort a small number of nodes to build out a tree and comparing ciphertexts only
with those nodes.  This limited leakage to comparisons between the dataset and
these nodes, reducing the leakage from a quadratic number of
comparisons to only linear.

Our first task will be extending the POPE
paradigm to high dimensional data.  The approach uses random hyperplanes
to form a partially-sorted search tree over multidimensional keys.
Random hyperplanes
have previously been used in the concept of random projection trees and
locality-sensitive hashing~\cite{STOC:DasFre08,charikar2002similarity}.  The
idea is as follows:

\begin{enumerate}\setlength\itemsep{0em}
\item The server initially stores an unsorted buffer of the entire dataset.
\item The client initiates a search for items that are similar to $a$.
\item The server asks the client to split the root node.
\item The client generates a random hyperplane $x$ and splits 
  the stored elements $b_i$ based on whether $b_i$ is above $x$ or not.
  (In the Euclidean
    space, this means checking whether
    $\langle x^T,b_i \rangle$ is positive.)
\item The client and server repeat the process with the relevant subtree
  until reaching an upper bound on the size of an unsorted leaf node.
\item The leaf node containing $a$ is returned to the client.
\end{enumerate}

The problem with this preliminary approach is a substantial chance that
nearby items will end up in different subtrees and therefore be
missed in the returned set.
To deal with this
problem, we propose to have the client can select a \emph{collection}
of hyperplanes $x_1,..., x_k$ and
split the tree based on $\sum_{i=1}^k \sign( \langle x_i^T, b \rangle )$.  This
technique allows us to control the probability that $a$ and $b$ will be denoted
as far (lying in different subtrees) when they are close (using tail bounds for
the binomial distribution). % Furthermore, it also creates a larger number of children for
%each node pushing from a binary to a B$^+$-tree.

\paragraph{Edit distance using partial suffix-tree encryption.}
Our second task is to build proximity search for edit distance.  For this
approach, we will build a partial version of a suffix tree which is often used
in string algorithms~\cite{mccreight1976space}.  Prior work by Chase and
Shen~\cite{chase2015substring} used an an encrypted suffix tree to answer
substring queries.

Our idea is to apply the online algorithm of a suffix-tree construction by
Ukkonen~\cite{Ukkonen95} and to build the suffix tree just-in-time as in
the POPE protocol. Again, the advantage will be that leakage is limited
to a ``need-to-know'' basis relative to the queries performed, rather
than leaking information about the entire dataset up-front.

The client will build a single level of the
suffix tree.  When the client searches for strings that are close $a$ they will
traverse the partially constructed suffix tree with the client/server
interactively building out the tree as necessary.  This approach will require
augmentations to a traditional suffix tree as the original searchable string
must be stored and queryable to build the tree on demand.  Balancing the speed
and privacy of querying the original string represents an important tradeoff in
this approach.

\subsection{Enhancing security of POPE}
\iffalse
Many of these defenses are designed to defeat leakage inference attacks.  The first approach is \emph{modularity} in the
sense of modular order-preserving encryption (M-OPE)~\cite{C:BolCheONe11}.  The
idea of M-OPE is to apply a secret random offset modulo the largest possible
message to a message before encrypting it (the secret random offset is chosen
once and fixed in the secret key), so that everything gets ``shifted.''
Since attacks still seem to apply to M-OPE, we propose to investigate more
fine-grained modularity as a defense. 

\paragraph{Random offset for each digit.}
We propose \emph{digit-modular} OPE (DM-OPE) where there is a
secret modular offset applied to each digit.  The base in which the data is
written could even itself be secret.  It becomes more complicated to make range
queries with DM-OPE, as it requires an exponential number of queries in the
number of ``wrap around'' digits in the query.  However, we propose to
investigate approximating the queries efficiently (with some false positives
that the client can filter out).
\fi

%\subsection{Enhancing security of POPE}
\paragraph{Forward security.} Leakage attacks are particularly problematic when
the adversary is able to correlate leakage from multiple queries.  Forward
security of searchable encryption can decouple the adversary's leakage and force
them to execute their attack with less information.  

POPE natively has forward security (i.e., updating an element doesn't leak
information about the other elements), although it was not considered in the
publication~\cite{CCS:RACY16}.  This is because the scheme doesn't maintain any
other index structure except the POPE tree. So, to update an element, one can
simply delete the element from the node it belongs and insert an updated
element to the unsorted buffer of the root. 

In this proposal, we plan to investigate whether we can further reduce the
leakage of the POPE scheme. 
%
%\begin{question}
%Can we reduce the leakage for the POPE scheme?
%\end{question}
In POPE, each search query leaks the ordering  for the following reasons: 
\begin{itemize}\setlength\itemsep{0em}
\item The tree is a search tree. For example, all elements in the
  left sub-tree are smaller than every element in the right subtree.
\item Once a ciphertext is inserting into a POPE tree, it never changes. This {\em
  deterministic} nature allows the attacker to trace when the ciphertext came
  in the tree, and how it was brought down to some leaf node.  
\end{itemize}

We plan to address these issues as follows. To address the first issue, for
each POPE node, the order of the links to its children may be shuffled. Since
POPE is an interactive protocol, when a tree node is created, we can slightly
modify the original protocol so that the client additionally change the order
of the links with a randomly selected permutation.\footnote{Similar ideas were used in the protocol of Ishai et al.~\cite{RSA:IKLO16} who use MPC and private information retrieval to hide tree traversal.}
%
Search can still be performed correctly even with this
modification, since the interactive guidance of the client can help the server
traverse the tree nodes correctly. 
    
To address the second issue, we observe that when the ciphertexts in an
unsorted buffer are streamed down to lower-level buffers during a search query,
the client first {\em decrypts} them in order to indicate the correct unsorted
lower-level buffer to which the ciphertexts should move. This procedure can be
easily augmented so that the client can stream the {re-reandomized cipehrtexts}
(instead of using the original ones deterministically) to lower-level unsorted
buffers. This way, along with the shuffling idea above, we can significantly
hide information about the location of lower-level buffers to which ciphertexts
have been streamed down. 

%\paragraph{Leakage over time.}
%While POPE allows each search query to {\it gradually} leak the ordering
%information of the underlying plaintexts, {\em most} of the ordering
%information will be leaked over many queries. 

%This begs the following question: 

%\begin{question}
%Can we still maintain a sufficient number of incomparable pairs of elements, even after
%  many range queries have been performed?  
%\end{question}

Another approach to reduce the leakage is leaving more ciphertexts in an
unsorted buffer (without affecting the performance significantly). For example,
a ciphertext in an unsorted buffer of the root node is incomparable with all
the other ciphertexts in the entire tree.  Moreover, in the POPE construction,
when an unsorted leaf buffer is full (i.e.,  containing more than $L$
ciphertexts), where $L$ is a threshold parameter, new $L$ leaf nodes are
created, and the ciphertexts are partitioned into $L$ newly created buffers.
This procedure greatly reduces the number of ciphertexts in unsorted buffers
and affects the security; in the worst case, some unsorted buffer will have
only a single ciphertext. With more careful partitioning, we can maintain the
number of incomparable pairs to be reasonably high even over many queries. 


Another possible direction is taking advantage of ORAM (Oblivious Random Access
Memory). Although they are too slow to used throughout the entire system
containing a large amount of data, we hope that ORAMs can be used effectively
for achieving stronger privacy for the sensitive sub-part of the system (e.g.,
the bottom parts of the POPE tree).  In fact, ORAMs have been used to minimize
the leakage for SSE (symmetric searchable encryption) schemes which support
keyword search over encrypted
data~\cite{NDSS:StePapShi14,C:GarMohPap16,RSA:IKLO16}. We will investigate how
to incorporate ORAM into POPE trees so that the resulting system enjoys
stronger privacy while only having marginal performance degradation.  

