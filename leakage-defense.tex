

\subsection{Component C-I:  Enhancing security of M-POPE}
One mitigation of the attacks we propose to look at is \emph{modularity} in the
sense of modular order-preserving encryption (M-OPE)~\cite{C:BolCheOne11}.  The
idea of M-OPE is to apply a secret random offset modulo the largest possible
message to a message before encrypting it (the secret random offset is chosen
once and fixed in the secret key), so that everything gets ``shifted.''
Although similar attacks seem to apply to M-OPE, we propose to investigate more
fine-grained modularity as a defense. 

\paragraph{Random offset for each digit.}
In particular, we propose \emph{digit-modular} OPE (DM-OPE) where there is a
secret modular offset applied to each digit.  The base in which the data is
written could even itself be secret.  It becomes more complicated to make range
queries with DM-OPE, as it requires an exponential number of queries in the
number of ``wrap around'' digits in the query.  However, we propose to
investigate approximating the queries efficiently (with some false positives
that the client can filter out).


\subsection{Component C-II:  Enhancing security of POPE}
A co-PI recently introduced a new cryptographic approach, called POPE, to
supporting range queries over encrypted data, providing stronger security than
previous order-preserving encryptions~\cite{CCS:RACY16}.  In contrast to
existing OPE schemes, the server builds a novel indexing structure called a
POPE tree, in which each node has a {\it unsorted buffer} and a sorted list of
elements.  Thanks to this, the scheme can perform {\it lazy indexing, by
sorting values only when necessary}. In particular, on each range query the
scheme sorts the part of the data that is accessed during the search, leaving
much of the data untouched.

More attractively, POPE also has forward security (i.e., updating an element
don't leak information about the other elements), although the paper didn't
consider this notion. This is because the scheme doesn't maintain any other
index structure except the POPE tree. So, to update an element, one can simply
delete the element from the node it belongs and insert an updated element to
the unsorted buffer of the root. 

\paragraph{Less leakage.}
In this proposal, we plan to investigate whether we can further reduce the
leakage of the POPE scheme. 

\begin{question}
Can we reduce the leakage for the POPE scheme?
\end{question}

We observe that in POPE, each search query leaks the ordering information
mainly for the following reasons: 

\begin{itemize}
\item The tree is essentially a search tree. For example, the elements on the
  left sub-tree is is smaller than those on the right.
 
\item Once a ciphertext comes in a POPE tree, it never changes. This {\em
  deterministic} nature allows the attacker to trace when the ciphertext came
  in the tree, and how it was brought down to some leaf node.  
\end{itemize}

We plan to address these issues as follows. To address the first issue, for
each POPE node, the order of the links to its children may be shuffled. Since
POPE is an interactive protocol, when a tree node is created, we can slightly
modify the original protocol so that the client additionally change the order
of the links with a randomly selected permutation. 
%
We note that the search can still be performed correctly even with this
modification, since the interactive guidance of the client can have the server
traverse the tree nodes correctly. 
    
To address the second issue, we observe that when the ciphertexts in an
unsorted buffer are streamed down to lower-level buffers during a search query,
the client first {\em decrypts} them in order to indicate the correct unsorted
lower-level buffer to which the ciphertexts should move. This procedure can be
easily augmented so that the client can stream the {re-reandomized cipehrtexts}
(instead of using the original ones deterministically) to lower-level unsorted
buffers. This way, along with the shuffling idea above, we can significantly
hide information about the location of lower-level buffers to which ciphertexts
have been streamed down. 

\paragraph{Leakage over time.}
While POPE allows each search query to {\it gradually} leak the ordering
information of the underlying plaintexts, {\em most} of the ordering
information will be leaked over many queries. This begs the following question: 

\begin{question}
Can we still maintain a sufficient number of incomparable pairs of elements, even after
  many range queries have been performed?  
\end{question}

One approach is to leave more ciphertexts in an unsorted buffer without
affecting the performance too much. For example, a ciphertext in an unsorted
buffer of the root node is incomparable with all the other ciphertexts in the
entire tree.  Moreover, in the POPE construction, when an unsorted leaf buffer
is full (i.e.,  containing more than $L$ ciphertexts), where $L$ is a threshold
parameter, new $L$ leaf nodes are created, and the ciphertexts are partitioned
into $L$ newly created buffers. This procedure greatly reduces the number of
ciphertexts in unsorted buffers and affects the security; in the worst case,
some unsorted buffer will have only a single ciphertext. With more careful
partitioning, we can maintain the number of incomparable pairs to be reasonably
high even over many queries. 


Another possible direction is taking advantage of ORAM (Oblivious Random Acess
Memory). Although they are too slow to used throughout the entire system
containing a large amount of data, we hope that ORAMs can be used effectively
for achieving stronger privacy for the sensitive sub-part of the system (e.g.,
the bottom parts of the POPE tree).  In fact, ORAMs have been used to minimize
the leakage for SSE (symmetric searchable encryption) schemes which support
keyword search over encrypted data~\cite{NDSS:StePapShi14,C:GarMohPap16}. We
plan investigate whether some part POPE trees can be modified and incorporated
with ORAMs so that the resulting system enjoys stronger privacy while only
having marginal performance degradation.  


todo: blind seer?
