%!TEX root = dbproposal.tex

\subsection{Enhancing security of POPE}
\iffalse
Many of these defenses are designed to defeat leakage inference attacks.  The first approach is \emph{modularity} in the
sense of modular order-preserving encryption (M-OPE)~\cite{C:BolCheONe11}.  The
idea of M-OPE is to apply a secret random offset modulo the largest possible
message to a message before encrypting it (the secret random offset is chosen
once and fixed in the secret key), so that everything gets ``shifted.''
Since attacks still seem to apply to M-OPE, we propose to investigate more
fine-grained modularity as a defense. 

\paragraph{Random offset for each digit.}
We propose \emph{digit-modular} OPE (DM-OPE) where there is a
secret modular offset applied to each digit.  The base in which the data is
written could even itself be secret.  It becomes more complicated to make range
queries with DM-OPE, as it requires an exponential number of queries in the
number of ``wrap around'' digits in the query.  However, we propose to
investigate approximating the queries efficiently (with some false positives
that the client can filter out).
\fi

%\subsection{Enhancing security of POPE}
\paragraph{Forward security.} Leakage attacks are particularly problematic when
the adversary is able to correlate leakage from multiple queries.  Forward
security of searchable encryption can decouple the adversary's leakage and force
them to execute their attack with less information.  

POPE natively has forward security (i.e., updating an element doesn't leak
information about the other elements), although it was not considered in the
publication~\cite{CCS:RACY16}.  This is because the scheme doesn't maintain any
other index structure except the POPE tree. So, to update an element, one can
simply delete the element from the node it belongs and insert an updated
element to the unsorted buffer of the root. 

In this proposal, we plan to investigate whether we can further reduce the
leakage of the POPE scheme. 
%
%\begin{question}
%Can we reduce the leakage for the POPE scheme?
%\end{question}
In POPE, each search query leaks the ordering  for the following reasons: 
\begin{itemize}\setlength\itemsep{0em}
\item The tree is a search tree. For example, all elements in the
  left sub-tree are smaller than every element in the right subtree.
\item Once a ciphertext is inserting into a POPE tree, it never changes. This {\em
  deterministic} nature allows the attacker to trace when the ciphertext came
  in the tree, and how it was brought down to some leaf node.  
\end{itemize}

We plan to address these issues as follows. To address the first issue, for
each POPE node, the order of the links to its children may be shuffled. Since
POPE is an interactive protocol, when a tree node is created, we can slightly
modify the original protocol so that the client additionally change the order
of the links with a randomly selected permutation.\footnote{Similar ideas were used in the protocol of Ishai et al.~\cite{RSA:IKLO16} who use MPC and private information retrieval to hide tree traversal.}
%
Search can still be performed correctly even with this
modification, since the interactive guidance of the client can help the server
traverse the tree nodes correctly. 
    
To address the second issue, we observe that when the ciphertexts in an
unsorted buffer are streamed down to lower-level buffers during a search query,
the client first {\em decrypts} them in order to indicate the correct unsorted
lower-level buffer to which the ciphertexts should move. This procedure can be
easily augmented so that the client can stream the {re-reandomized cipehrtexts}
(instead of using the original ones deterministically) to lower-level unsorted
buffers. This way, along with the shuffling idea above, we can significantly
hide information about the location of lower-level buffers to which ciphertexts
have been streamed down. 

%\paragraph{Leakage over time.}
%While POPE allows each search query to {\it gradually} leak the ordering
%information of the underlying plaintexts, {\em most} of the ordering
%information will be leaked over many queries. 

%This begs the following question: 

%\begin{question}
%Can we still maintain a sufficient number of incomparable pairs of elements, even after
%  many range queries have been performed?  
%\end{question}

Another approach to reduce the leakage is leaving more ciphertexts in an
unsorted buffer (without affecting the performance significantly). For example,
a ciphertext in an unsorted buffer of the root node is incomparable with all
the other ciphertexts in the entire tree.  Moreover, in the POPE construction,
when an unsorted leaf buffer is full (i.e.,  containing more than $L$
ciphertexts), where $L$ is a threshold parameter, new $L$ leaf nodes are
created, and the ciphertexts are partitioned into $L$ newly created buffers.
This procedure greatly reduces the number of ciphertexts in unsorted buffers
and affects the security; in the worst case, some unsorted buffer will have
only a single ciphertext. With more careful partitioning, we can maintain the
number of incomparable pairs to be reasonably high even over many queries. 


Another possible direction is taking advantage of ORAM (Oblivious Random Access
Memory). Although they are too slow to used throughout the entire system
containing a large amount of data, we hope that ORAMs can be used effectively
for achieving stronger privacy for the sensitive sub-part of the system (e.g.,
the bottom parts of the POPE tree).  In fact, ORAMs have been used to minimize
the leakage for SSE (symmetric searchable encryption) schemes which support
keyword search over encrypted
data~\cite{NDSS:StePapShi14,C:GarMohPap16,RSA:IKLO16}. We will investigate how
to incorporate ORAM into POPE trees so that the resulting system enjoys
stronger privacy while only having marginal performance degradation.  


\input{leakage-blindseer}

\subsection{Experimental performance and security evaluation}

\emph{Throughout all phases of the project}, the most promising of our
schemes will be implemented and tested on realistic scenarios.
Indeed, we plan to include
experimental components in many of our published artifacts, with
links to the open source implementations developed.

In order to evaluate the real-world performance of our schemes, we will
be careful to use realistic and relevant datasets and queries. Tools
such as the automatic test-suite generator developed in the IARPA SPAR
project \cite{HH14,varia2015automated} will be used to generate
repeatable and realistic experiments.

Our experimental evaluations will also cover the \emph{security} of our
schemes. Frequently the development of applied cryptographic tools
relies exclusively on security proofs in
discussing privacy. Our scalable approaches indeed contain security
proofs, but also usually entail some limited information leakage.
We will use empirical tools to highlight the practical
implications of this limited leakage, including leakage under known
attacks. For example, in \cite{CCS:RACY16}, two of the co-PIs not only
evaluated the number of incomparable ciphertext pairs in theory, but
also tested this leakage on a publicly-available salary database.
