%!TEX root = dbproposal.tex

\subsection{Extending BlindSeer}
\label{sec:ext-blindseer}

\paragraph{Prior work.} A co-PI was a member of the team that developed
BlindSeer~\cite{SP:PKVKMC14,SP:FVKKKM15}, which is a database management system
that provides privacy.
%
BlindSeer has three main players: the \emph{server} $\mathsf{S}$,
{\em index server} $\sf IS$, and {\em client} $\sf C$. The server $\sf S$,
holds the DB and outsources an encrypted copy of the DB to a third party,
the index server $\sf IS$. The server $\sf S$  also builds an
encrypted Bloom filter (BF) search tree over the DB and sends it to $\sf IS$. The
client $\sf C$ sends search queries to $\sf IS$ and obtains encrypted
results, the decryption key for which is secret-shared
between $\sf C$ and $\sf IS$. These decryptions key are arranged in an offline
setup stage, using shuffling and homomorphic public-key
encryption.

BlindSeer provides the following privacy guarantees:
\begin{itemize}\setlength\itemsep{0em}
\item Query privacy: $\sf S$ is not involved with the search protocol at
  all, so the client's queries are hidden from $\sf S$. Moreover, $\sf IS$ holds
    the {\em shuffled, encrypted} database, so the client's queries remain
    private to a great degree against $\sf IS$. 

\item Data privacy: $\sf IS$ deals with only the encrypted database, so the
records are hidden from $\sf IS$. Moreover, $\sf IS$ returns only the records
that satisfy the client query, and therefore, $\sf C$ cannot arbitrarily access
all the records in the database.  
\end{itemize}

\subsubsection{Proposed Work}
When a database is outsourced, the database owner is often the client
itself, in which case we don't need to worry about whether the plaintext data
would be leaked to the client.  In this proposal, we will consider this setting
of the client as the data owner and significantly simplify the architecture of
the BlindSeer system. This will bring us a construction that has better
efficiency and a richer set of functionalities. In particular:

\begin{itemize}\setlength\itemsep{0em}
\item {\em Much simpler, more efficient setup.}
In this new simpler threat model, the client can be regarded as playing as both
$\sf S$ and $\sf C$ in the original BlindSeer architecture. Therefore, the
client can just hold one symmetric key in contrast to the original BlindSeer
system where a slow public-key encryption scheme and a random shuffling
must be introduced in the setup stage, none of which we need in our new
setting. This also gives us {\em better backward compatibility}.

\item {\em MPC is not necessary.} In the original BlindSeer system, in order to
hide from $\sf C$ the BF data stored in each node of the search tree, $\sf
C$ and $\sf IS$ have to execute costly MPC computation. In our setting, the
    client can simply ask for the necessary encrypted BF data and decrypt them,
    since we don't need to hide anything from the client.  


\item {\em Dynamic record insertion.} In the original BlindSeer, one cannot
insert new encrypted BF data to the search tree dynamically.  It is mainly
because the decryption key for each record must be arranged in the setup
stage.
%
Furthermore, in the original BlindSeer, BF data are encrypted with a very
simple mechanism of one-time pad so that MPC computation may be reasonably
efficient. Dynamic addition of BF data will lead to a more complicated
encryption structure, and the MPC computation will be much more costly.
In our setting, however, we don't need any key setup, nor MPC computation.
Therefore, we can add BF data directly to the search tree with much more
efficiency.  
\end{itemize}

\noindent We believe that it is important to provide an efficient solution for various
settings. For use cases where this new setting is appropriate, we believe this simplified
construction will be an order of magnitude faster than the current BlindSeer system.

\paragraph{Proximity of high-dimensional data.}
BlindSeer already provides conjunctions and range queries.  These queries can be combined to answer proximity queries on a Euclidean space.
In particular, a query that searches for the points close to $(x, y)$ can be defined as a 2D rectangle defined by the top-left point $(x_1, y_1)$ and the
bottom-right point $(y_1, y_2)$ can be described with range queries and
conjunctions as follows: $$ x_1 \le x \le x_2 ~~{\sf AND}~~~ y_1 \le y \le y_2.
$$ This technique can be easily extended to data with multiple dimensions. 

\paragraph{Graph structure and the shortest path.}
Using Bloom filters we can encode a graph structure as follows:
\begin{itemize}
\item For each edge $(a, b)$ from vertex $a$ to vertex $b$, we insert an
  encryption $c = \Enc((a,b) \| w(a,b) )$, where $w(a,b)$ is the weight of the edge
    $(a,b)$. Moreover, have the ciphertext $c$ indexed by a BF keyword `$\sf edge$:a*'. 
\end{itemize}

\noindent
We can find all the neighbors of vertex $a$ along with the weight of the
associated edge. Therefore, we can run variants of Dijkstra's algorithm and
compute compute the shortest path, given two vertices $a$ and $b$ and a limit
on the maximum number of arcs. The key to this approach is the ``native''
ability of Bloom filters to handle conjunction queries.  BlindSeer is based on
the Bloom filters so it can support proximity and graph structure by adding
relevant keyword index appropriately.
%
%Moreover, considering that BlindSeer allows disjunctions and conjunctions, the
%client can enjoy a much richer set of functionalities.  


\def\HHH{{\cal H}}
\subsection{Enhancing security of BlindSeer}

In BlindSeer, the search query is executed by the client traversing the Bloom filter
search tree. In particular, in each node of the tree, the client and the server
execute the following:
\begin{enumerate}\setlength\itemsep{0em}
\item For each keyword $\alpha$ in the query, the client computes a hash on
$\alpha$, based on which the look-up positions $H(\alpha) =  (h_1, h_2, ...,
h_\eta)$ for the BF data are identified. Here, $\eta$ is a system
parameter. 

\item The client sends $\HHH = \{H(\alpha_1), \ldots, H(\alpha_q)\}$,
  where $\alpha_1,\ldots,\alpha_q$ are the keywords used in the query.

\item The client and the server execute a protocol using $\HHH$ and the
encrypted BF as input, so that the client knows whether the given query is
satisfied. 
\end{enumerate}

The message $\HHH$ (i.e., the look-up positions) from the client to the server
leaks $H(\alpha)$ to a significantly degree, since $q$ is a small number most
of the time. Moreover, $H(\alpha)$ is a deterministic function on $\alpha$.
This implies that the server can infer with a reasonable probability whether
two queries contain the same keyword, although it doesn't know what the keyword
is.  If the server is given  auxiliary information about query statistics, the
server may be able to infer queries. 

%\paragraph{Removing the leakage of BF indices.}

It is difficult to reduce the leakage in the original
BlindSeer system. In particular, the above step 3 (i.e., the protocol execution
to check whether the given query is satisfied) is performed using secure
two-party computation based on Yao's garbled circuit. It is critical
for the logic to be as simple as possible, in order to obtain the desired
efficiency. To reduce the leakage, it is natural to use more sophisticated
cryptographic mechanisms, but then the step 3 of secure computation would be
significantly slower. 

However, in Section~\ref{sec:ext-blindseer} we noted secure computation is not
necessary in the two-party setting. In this case, we can actually remove the
leakage by completely hiding $\HHH$. As one promising direction, we can achive
this goal by storing the encrypted BF using ORAM techniques. Note that the
$\HHH$ can be regarded as the metadata (i.e., ``addresses") for the encrypted
data (i.e., BF contents), which fits perfectly into the scneario that ORAM
tries to make secure. 
%
Even using the ORAM, we expect that the resulting system will be faster than
the system using two-party secure computation, since two-party computation is
known to be significantly slower than ORAM. 
