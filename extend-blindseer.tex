%!TEX root = dbproposal.tex

\subsection{Extending BlindSeer}
\label{sec:ext-blindseer}

\paragraph{Prior work.} A co-PI was a member of the team that developed
BlindSeer~\cite{SP:PKVKMC14,SP:FVKKKM15}, which is a database management system
that provides privacy.
%
BlindSeer has three main players: the \emph[server} $\mathsf{S}$,
{\em index server} $\sf IS$, and {\em client} $\sf C$. The server $\sf S$,
holds the DB and outsources an encrypted copy of the DB to a third party,
the index server $\sf IS$. The server $\sf S$  also builds an
encrypted Bloom filter (BF) search tree over the DB and sends it to $\sf IS$. The
client $\sf C$ sends search queries to $\sf IS$ and obtains encrypted
results, the decryption key for which is secret-shared
between $\sf C$ and $\sf IS$. These decryptions key are arranged in an offline
setup stage, using shuffling and homomorphic public-key
encryption.

BlindSeer provides the following privacy guarantees:
\begin{itemize}\setlength\itemsep{0em}
\item Query privacy: $\sf S$ is not involved with the search protocol at
  all, so the client's queries are hidden from $\sf S$. Moreover, $\sf IS$ holds
    the {\em shuffled, encrypted} database, so the client's queries remain
    private to a great degree against $\sf IS$. 

\item Data privacy: $\sf IS$ deals with only the encrypted database, so the
records are hidden from $\sf IS$. Moreover, $\sf IS$ returns only the records
that satisfy the client query, and therefore, $\sf C$ cannot arbitrarily access
all the records in the database.  
\end{itemize}

\subsubsection{Proposed Work}
When a database is outsourced, the database owner is often the client
itself, in which case we don't need to worry about whether the plaintext data
would be leaked to the client.  In this proposal, we will consider this setting
of the client as the data owner and significantly simplify the architecture of
the BlindSeer system. This will bring us a construction that has better
efficiency and a richer set of functionalities. In particular:

\begin{itemize}\setlength\itemsep{0em}
\item {\em Much simpler, more efficient setup.}
In this new simpler threat model, the client can be regarded as playing as both
$\sf S$ and $\sf C$ in the original BlindSeer architecture. Therefore, the
client can just hold one symmetric key in contrast to the original BlindSeer
system where a slow public-key encryption scheme and a random shuffling
must be introduced in the setup stage, none of which we need in our new
setting. This also gives us {\em better backward compatibility}.

\item {\em MPC is not necessary.} In the original BlindSeer system, in order to
hide from $\sf C$ the BF data stored in each node of the search tree, $\sf
C$ and $\sf IS$ have to execute costly MPC computation. In our setting, the
    client can simply ask for the necessary encrypted BF data and decrypt them,
    since we don't need to hide anything from the client.  


\item {\em Dynamic record insertion.} In the original BlindSeer, one cannot
insert new encrypted BF data to the search tree dynamically.  It is mainly
because the decryption key for each record must be arranged in the setup
stage.
%
Furthermore, in the original BlindSeer, BF data are encrypted with a very
simple mechanism of one-time pad so that MPC computation may be reasonably
efficient. Dynamic addition of BF data will lead to a more complicated
encryption structure, and the MPC computation will be much more costly.
In our setting, however, we don't need any key setup, nor MPC computation.
Therefore, we can add BF data directly to the search tree with much more
efficiency.  
\end{itemize}

\noindent We believe that it is important to provide an efficient solution for various
settings. For use cases where this new setting is appropriate, we believe this simplified
construction will be an order of magnitude faster than the current BlindSeer system.

\paragraph{Proximity of high-dimensional data.}
BlindSeer already provides conjunctions and range queries.  These queries can be combined to answer proximity queries on a Euclidean space.
In particular, a query that searches for the points close to $(x, y)$ can be defined as a 2D rectangle defined by the top-left point $(x_1, y_1)$ and the
bottom-right point $(y_1, y_2)$ can be described with range queries and
conjunctions as follows: $$ x_1 \le x \le x_2 ~~{\sf AND}~~~ y_1 \le y \le y_2.
$$ This technique can be easily extended to data with multiple dimensions. 

\paragraph{Graph structure and the shortest path.}
Using Bloom filters we can encode a graph structure as follows:
\begin{itemize}
\item For each edge $(a, b)$ from vertex $a$ to vertex $b$, we insert an
  encryption $c = \Enc((a,b) \| w(a,b) )$, where $w(a,b)$ is the weight of the edge
    $(a,b)$. Moreover, have the ciphertext $c$ indexed by a BF keyword `$\sf edge$:a*'. 
\end{itemize}

\noindent
We can find all the neighbors of vertex $a$ along with the weight of the
associated edge. Therefore, we can run variants of Dijkstra's algorithm and
compute compute the shortest path, given two vertices $a$ and $b$ and a limit
on the maximum number of arcs. The key to this approach is the ``native''
ability of Bloom filters to handle conjunction queries.  BlindSeer is based on
the Bloom filters so it can support proximity and graph structure by adding
relevant keyword index appropriately.
%
%Moreover, considering that BlindSeer allows disjunctions and conjunctions, the
%client can enjoy a much richer set of functionalities.  
